# CURSO DE ASSEMBLY
üë®‚Äç‚öñÔ∏èASSEMBLY √â UMA LINGUAGEM DE PROGRAMA√á√ÉO.

<img src="FOTO.png" align="center" width="400"> <br>

## VIS√ÉO PANOR√ÇMICA:
| PERGUNTA | RESPOSTA |
| :---: | :---: |
| DATA DE CRIA√á√ÉO | DESCONHECIDO |
| NOME DO CRIADOR | DESCONHECIDO | 
| SIGNIFICADO DO NOME | Ela √© chamada de "Assembly" porque utiliza mnem√¥nicos e s√≠mbolos (como ADD para adi√ß√£o) que s√£o mais leg√≠veis do que os c√≥digos bin√°rios brutos usados pela CPU |
| √â BASEADA NO | Arquitetura de CPU |
| EXTEN√á√ÉO DO ARQUIVO | ".asm" ou ".s" |
| √â MAIS USADA | Programa√ß√£o de sistemas embarcados |

- **Data de Cria√ß√£o**: A linguagem Assembly n√£o tem uma data de cria√ß√£o espec√≠fica, pois ela √© mais uma fam√≠lia de linguagens de baixo n√≠vel do que uma √∫nica linguagem. O Assembly surgiu nos primeiros dias da computa√ß√£o e tem evolu√≠do com o desenvolvimento de arquiteturas de processador.

- **Nome do Criador**: N√£o h√° um √∫nico criador da linguagem Assembly, pois ela est√° intrinsecamente ligada ao desenvolvimento de arquiteturas de processador. Diferentes arquiteturas de CPU t√™m sua pr√≥pria linguagem Assembly associada, e muitos engenheiros e projetistas de hardware contribu√≠ram para o desenvolvimento dessas linguagens ao longo do tempo.

- **Significado do Nome**: O termo "Assembly" refere-se ao fato de que a linguagem Assembly √© uma representa√ß√£o simb√≥lica da linguagem de m√°quina do processador. Ela √© chamada de "Assembly" porque utiliza mnem√¥nicos e s√≠mbolos (como ADD para adi√ß√£o) que s√£o mais leg√≠veis do que os c√≥digos bin√°rios brutos usados pela CPU.

- **Linguagem Baseada**: A linguagem Assembly √© espec√≠fica para cada arquitetura de processador e n√£o √© baseada em nenhuma outra linguagem. Cada arquitetura de CPU tem sua pr√≥pria linguagem Assembly com instru√ß√µes e sintaxe exclusivas.

- **Extens√£o do Arquivo**: A extens√£o do arquivo Assembly pode variar dependendo do conjunto de ferramentas de montagem (assembler) usado, mas comumente √© ".asm" ou ".s". Por exemplo, "meu_programa.asm" pode ser um nome de arquivo Assembly.

- **Usos Principais**: A linguagem Assembly √© usada principalmente em cen√°rios que requerem controle direto sobre o hardware do computador ou otimiza√ß√£o de baixo n√≠vel. Seus usos incluem:
  - Programa√ß√£o de sistemas embarcados.
  - Desenvolvimento de drivers de dispositivos.
  - Programa√ß√£o de firmware.
  - Otimiza√ß√£o de c√≥digo cr√≠tico de desempenho.
  - Seguran√ßa e explora√ß√£o de vulnerabilidades.
  - Depura√ß√£o de c√≥digo de baixo n√≠vel.
  - Programa√ß√£o de sistemas operacionais.

A programa√ß√£o em Assembly √© geralmente evitada em aplica√ß√µes de software de alto n√≠vel, devido √† sua complexidade e √† falta de portabilidade entre diferentes arquiteturas de CPU. No entanto, ela desempenha um papel fundamental no desenvolvimento de sistemas de baixo n√≠vel e software que exige controle preciso sobre o hardware. Cada arquitetura de processador tem sua pr√≥pria linguagem Assembly, o que a torna altamente especializada para a plataforma espec√≠fica em que √© usada.

## SUA HIST√ìRIA:
1. **Origens na Linguagem de M√°quina (Machine Language)**: No in√≠cio da era dos computadores, os programas eram escritos diretamente na linguagem de m√°quina, que consistia em sequ√™ncias bin√°rias de 0s e 1s compreendidas pelos processadores. Escrever programas nessa linguagem era tedioso e propenso a erros.

2. **Desenvolvimento da Linguagem Assembly**: Para simplificar a programa√ß√£o e tornar os programas mais leg√≠veis, as linguagens Assembly foram desenvolvidas. Elas utilizam mnem√¥nicos (abrevia√ß√µes simb√≥licas) para representar instru√ß√µes e operandos, que s√£o traduzidos diretamente para as instru√ß√µes de linguagem de m√°quina correspondentes.

3. **Primeiras Linguagens Assembly**: As primeiras linguagens Assembly foram desenvolvidas nos anos 1940 e 1950, coincidindo com o surgimento dos primeiros computadores digitais program√°veis. Exemplos incluem as linguagens Assembly para o ENIAC e o UNIVAC, dois dos primeiros computadores eletr√¥nicos.

4. **Padroniza√ß√£o e Evolu√ß√£o**: Ao longo do tempo, v√°rias conven√ß√µes e padr√µes surgiram para as linguagens Assembly, tornando-as mais acess√≠veis e port√°veis entre diferentes arquiteturas de processadores. Exemplos incluem o padr√£o de Assembly do IBM System/360 e o padr√£o da fam√≠lia x86 de processadores Intel.

5. **Desenvolvimento de Compiladores**: Com o avan√ßo da tecnologia de compiladores, tornou-se poss√≠vel escrever programas em linguagens de alto n√≠vel, como C, C++, Java, entre outras, e compil√°-los para c√≥digo de m√°quina. Isso reduziu a necessidade de programa√ß√£o em Assembly para muitas aplica√ß√µes, embora ainda seja usado em situa√ß√µes que exigem controle de baixo n√≠vel ou otimiza√ß√£o de desempenho.

6. **Uso Cont√≠nuo em Sistemas Embarcados e de Baixo N√≠vel**: Apesar do decl√≠nio relativo na programa√ß√£o em Assembly para aplicativos de prop√≥sito geral, ainda √© amplamente utilizado em sistemas embarcados, drivers de dispositivo, firmware e outras √°reas onde o controle de hardware de baixo n√≠vel √© necess√°rio.

7. **Ensino e Aprendizado**: A programa√ß√£o em Assembly ainda √© ensinada em cursos de ci√™ncia da computa√ß√£o e engenharia de computa√ß√£o como uma introdu√ß√£o ao funcionamento interno dos computadores e √† arquitetura de processadores. O conhecimento em Assembly √© valorizado para entender os conceitos fundamentais de computa√ß√£o.

## CARACTERISTICAS:
### POSITIVAS:
1. **Controle de Hardware**: Assembly permite um controle direto e preciso sobre o hardware do computador. Isso √© essencial para programar sistemas embarcados, drivers de dispositivos e software de baixo n√≠vel.

2. **Efici√™ncia de C√≥digo**: A programa√ß√£o em Assembly permite a cria√ß√£o de c√≥digo altamente otimizado para tarefas espec√≠ficas. Isso pode resultar em um desempenho significativamente melhor do que as linguagens de alto n√≠vel.

3. **Tamanho Compacto**: Os programas em Assembly tendem a ser muito pequenos em tamanho devido √† falta de abstra√ß√£o de alto n√≠vel. Isso √© crucial em sistemas com restri√ß√µes de recursos.

4. **Baixo Overhead**: Como n√£o h√° camadas de abstra√ß√£o significativas entre o c√≥digo e o hardware, o c√≥digo Assembly geralmente tem baixo overhead, o que √© importante para sistemas em tempo real.

5. **Aprendizado Profundo**: A programa√ß√£o Assembly ensina aos programadores os detalhes internos da arquitetura do computador, o que pode ser valioso para entender como as linguagens de alto n√≠vel funcionam por baixo dos panos.

6. **Portabilidade Limitada**: Embora possa parecer uma desvantagem, a falta de portabilidade do c√≥digo Assembly pode ser uma vantagem em sistemas espec√≠ficos onde a uniformidade da plataforma √© desejada.

7. **Compreens√£o de Depura√ß√£o**: A depura√ß√£o em Assembly pode ajudar os programadores a entender as causas de problemas de baixo n√≠vel, como falhas de hardware ou problemas de desempenho.

8. **Recursos Espec√≠ficos da Arquitetura**: Assembly permite aproveitar recursos espec√≠ficos da arquitetura do processador, como instru√ß√µes vetoriais ou extens√µes SIMD (Single Instruction, Multiple Data), para realizar c√°lculos intensivos de maneira eficiente.

### NEGATIVAS:
1. **Complexidade**: Assembly √© uma linguagem de baixo n√≠vel e, portanto, √© altamente detalhada e requer um conhecimento profundo da arquitetura do processador. Isso torna a programa√ß√£o em Assembly mais complexa do que linguagens de alto n√≠vel.

2. **Portabilidade Limitada**: Os programas Assembly s√£o altamente dependentes da arquitetura do processador, o que significa que o c√≥digo Assembly escrito para uma arquitetura espec√≠fica geralmente n√£o √© port√°vel para outras arquiteturas sem modifica√ß√£o significativa.

3. **Manuten√ß√£o Dif√≠cil**: A manuten√ß√£o de c√≥digo Assembly pode ser muito trabalhosa devido √† falta de abstra√ß√£o e √† necessidade de lidar diretamente com detalhes de hardware. Pequenas altera√ß√µes podem exigir uma revis√£o extensiva do c√≥digo.

4. **Curva de Aprendizado √çngreme**: Programar em Assembly exige um aprendizado extenso e pode ser desafiador para desenvolvedores iniciantes. √â necess√°rio um entendimento profundo da arquitetura e do funcionamento interno do computador.

5. **C√≥digo Verboso**: A programa√ß√£o em Assembly geralmente requer muito mais c√≥digo para realizar tarefas simples em compara√ß√£o com linguagens de alto n√≠vel. Isso torna o c√≥digo Assembly mais dif√≠cil de ler e escrever.

6. **Falta de Recursos de Alto N√≠vel**: Assembly carece de muitos recursos de alto n√≠vel, como gerenciamento autom√°tico de mem√≥ria, tipos de dados complexos e bibliotecas prontas para uso, o que pode tornar o desenvolvimento demorado.

7. **Baixa Produtividade**: A programa√ß√£o em Assembly pode ser lenta e exigir muito tempo para desenvolver, o que a torna impratic√°vel para projetos que t√™m restri√ß√µes de tempo.

8. **Depend√™ncia de Documenta√ß√£o Espec√≠fica da Arquitetura**: Cada arquitetura de processador possui sua pr√≥pria documenta√ß√£o e conjunto de instru√ß√µes, o que requer que os desenvolvedores se familiarizem com a documenta√ß√£o espec√≠fica da plataforma que est√£o usando.

9. **Falta de Ferramentas Modernas**: A disponibilidade de ferramentas de desenvolvimento e depura√ß√£o para Assembly pode ser limitada em compara√ß√£o com linguagens de alto n√≠vel. Isso pode tornar o processo de desenvolvimento mais dif√≠cil.

# SUBSIDIOS:
- [CURSO CRIADO PELO "FERNANDO ANSELMO"](https://youtube.com/playlist?list=PLxTkH01AauxRm0LFLlOA9RR5O6hBLqBtC&si=7j17sanq1xaFK4y7)
- [CURSO FEITO PELO VILHALVA](https://github.com/VILHALVA)
- [VEJA A DOCUMENTA√á√ÉO DA ORACLE](https://docs.oracle.com/cd/E19253-01/817-5477/817-5477.pdf)
- [VEJA A DOCUMENTA√á√ÉO DA IBM](https://www.ibm.com/docs/en/aix/7.2?topic=aix-assembler-language-reference)
- [VEJA O MANUAL](./MANUAL.md)
- [VEJA A SINTAXE](./SINTAXE.md)



